# -*- coding: utf-8 -*-
"""Robotics_miniproject.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HHVzkz1quurjqn6XdNvBr8VFK458FyY-

Name:

Snigdha Labh(17070123105)

Satyaki Tatte (17070123112)

Ventrapragada Sai Shravani (17070123120)

Vinayak Dev Kuanr (17070123121)

BATCH: G-5 (2017-21)

BRANCH: E&TC
"""

#grayscale, RGB, BGR, HSV
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Dropout, Flatten, Dense, Activation, BatchNormalization
import os
import numpy as np
import matplotlib.pyplot as plt
import re
import random
import cv2

_URL = 'https://storage.googleapis.com/mledu-datasets/cats_and_dogs_filtered.zip'
path_to_zip = tf.keras.utils.get_file('cats_and_dogs.zip', origin=_URL, extract=True)
PATH = os.path.join(os.path.dirname(path_to_zip), 'cats_and_dogs_filtered')

train_dir = os.path.join(PATH, 'train')
validation_dir = os.path.join(PATH, 'validation')
train_cats_dir = os.path.join(train_dir, 'cats')  # directory with our training cat pictures
train_dogs_dir = os.path.join(train_dir, 'dogs')  # directory with our training dog pictures
validation_cats_dir = os.path.join(validation_dir, 'cats')  # directory with our validation cat pictures
validation_dogs_dir = os.path.join(validation_dir, 'dogs')  # directory with our validation dog pictures

cats_tr = os.listdir(train_cats_dir)
dogs_tr = os.listdir(train_dogs_dir)

cats_val = os.listdir(validation_cats_dir)
dogs_val = os.listdir(validation_dogs_dir)

cats_tr = [os.path.join(train_cats_dir, x) for x in cats_tr]
dogs_tr = [os.path.join(train_dogs_dir, x) for x in dogs_tr]
cats_val = [os.path.join(validation_cats_dir, x) for x in cats_val]
dogs_val = [os.path.join(validation_dogs_dir, x) for x in dogs_val]

total_train = cats_tr + dogs_tr
total_val = cats_val + dogs_val

BATCH_SIZE = 128
EPOCHS = 50
IMG_HEIGHT = 150
IMG_WIDTH = 150

def data_gen(img_names, batch_size, colorspace):
    c = 0
    n = img_names #List of training images
    random.shuffle(n)
        
    while (True):
        img = np.zeros((batch_size, 150, 150, 3)).astype('float')
        labels = []
      
        #initially from 0 to 16, c = 0. 
        
        for i in range(c, c+batch_size):
            #print(i)
            train_img = cv2.imread(n[i])
            train_img =  cv2.resize(train_img, (150, 150))# Read an image from folder and resize
            
            if colorspace == 'hsv':
                train_img = cv2.cvtColor(train_img, cv2.COLOR_BGR2HSV)
                train_img[0, :, :] = train_img[0, :, :]/180.
                train_img[1:3, :, :] = train_img[1:3, :, :]/255.
            elif colorspace == 'rgb':
                train_img = cv2.cvtColor(train_img, cv2.COLOR_BGR2RGB)
            elif colorspace == 'grayscale':
                train_img = cv2.cvtColor(train_img, cv2.COLOR_BGR2GRAY)
            #elif colorspace == 'xyz':
                #train_img = cv2.cvtColor(train_img, cv2.COLOR_BGR2XYZ)

            if colorspace != 'hsv':
                train_img = train_img/255           

            img[i-c] = train_img #add to array - img[0], img[1], and so on.
            if len(re.findall('dog', n[i])) == 3:
                labels.append(0)
            else: 
                labels.append(1)
        labels = np.array(labels)
        c+=batch_size
        if(c+batch_size>=len(img_names)):
            c=0
            random.shuffle(n)
                      # print "randomizing again"
        yield img, labels

def create_model():
    model = Sequential()

    model.add(Conv2D(32, (3, 3), activation='relu', input_shape=(IMG_WIDTH, IMG_HEIGHT, 3)))
    model.add(Conv2D(32, (3, 3), activation='relu'))
    model.add(BatchNormalization())
    model.add(MaxPooling2D(pool_size=(2, 2)))
    model.add(Dropout(0.5))

    model.add(Conv2D(64, (3, 3), activation='relu'))
    model.add(Conv2D(64, (3, 3), activation='relu'))
    model.add(BatchNormalization())
    model.add(MaxPooling2D(pool_size=(2, 2)))
    model.add(Dropout(0.5))

    model.add(Conv2D(128, (3, 3), activation='relu'))
    model.add(Conv2D(64, (3, 3), activation='relu'))
    model.add(BatchNormalization())
    model.add(MaxPooling2D(pool_size=(2, 2)))
    model.add(Dropout(0.5))

    model.add(Flatten())
    model.add(Dense(128, activation='relu'))
    model.add(Dense(512, activation='relu'))
    model.add(BatchNormalization())
    model.add(Dropout(0.5))
    model.add(Dense(1, activation='sigmoid'))

    model.compile(optimizer='adam',
                  loss=tf.keras.losses.BinaryCrossentropy(from_logits=True),
                  metrics=['accuracy'])
    return model

def create_model():
    
    IMG_SHAPE = (160, 160, 3)
    base_model = tf.keras.applications.MobileNetV2(input_shape=IMG_SHAPE, include_top=False, weights="imagenet")
    #base_model.summary()
    base_model.trainable = True
    global_average_layer = tf.keras.layers.GlobalAveragePooling2D()(base_model.output)
    prediction_layer = tf.keras.layers.Dense(1, activation='sigmoid')(global_average_layer)
    model = tf.keras.models.Model(inputs=base_model.input, outputs=prediction_layer)
    #model.summary()
    model.compile(optimizer=tf.keras.optimizers.Adam(lr=0.0001), loss=tf.keras.losses.BinaryCrossentropy(from_logits=True), metrics=["accuracy"])
    return model

colorspaces = ['bgr', 'hsv', 'rgb', 'grayscale']

history = []
for colorspace in colorspaces:
    model = create_model()
    train_data_gen = data_gen(total_train, BATCH_SIZE, colorspace)
    val_data_gen = data_gen(total_val, BATCH_SIZE, colorspace)
    history.append(model.fit(
                  train_data_gen,
                  steps_per_epoch=len(total_train) // BATCH_SIZE,
                  epochs=EPOCHS,
                  validation_data=val_data_gen,
                  validation_steps=len(total_val) // BATCH_SIZE
                  ))

"""Plotting the training data"""

epochs_range = range(EPOCHS)

plt.figure(figsize=(20, 10))
plt.subplot(2, 2, 1)
for i, colorspace in enumerate(colorspaces):
    plt.plot(epochs_range, history[i].history['accuracy'], label=colorspace)
plt.legend(loc='lower right')
plt.title('Training Accuracy')

plt.subplot(2, 2, 2)
for i, colorspace in enumerate(colorspaces):
    plt.plot(epochs_range, history[i].history['val_accuracy'], label=colorspace)
plt.legend(loc='lower right')
plt.title('Validation Accuracy')

plt.subplot(2, 2, 3)
for i, colorspace in enumerate(colorspaces):
    plt.plot(epochs_range, history[i].history['loss'], label=colorspace)
plt.legend(loc='upper right')
plt.title('Training Loss')

plt.subplot(2, 2, 4)
for i, colorspace in enumerate(colorspaces):
    plt.plot(epochs_range, history[i].history['val_loss'], label=colorspace)
plt.legend(loc='upper right')
plt.title('Validation Loss')
plt.show()



y_test = []
for path in total_val:
    if len(re.findall('dog', path)) == 3:
        y_test.append(0)
    else: 
        y_test.append(1)

y_pred = []
for path in total_val:
    bgr = cv2.imread(path)
    bgr = cv2.resize(bgr, (160, 160))
   RGB = cv2.cvtColor(bgr, cv2.COLOR_BGR2RGB)
    lab = cv2.cvtColor(bgr, cv2.COLOR_BGR2Lab)
    luv = cv2.cvtColor(bgr, cv2.COLOR_BGR2LUV)
    xyz = cv2.cvtColor(bgr, cv2.COLOR_BGR2XYZ)

    bgr = bgr/127.5 - 1 
    RGB = ycrcb/127.5 - 1 
    lab = lab/127.5 - 1 
    luv = luv/127.5 - 1 
    xyz = xyz/127.5 - 1 

    bgr = np.expand_dims(bgr, axis=0)
    ycrcb = np.expand_dims(ycrcb, axis=0)
    lab = np.expand_dims(lab, axis=0)
    luv = np.expand_dims(luv, axis=0)
    xyz = np.expand_dims(xyz, axis=0)

    label_pred = (model_bgr.predict(bgr) + model_ycrcb.predict(ycrcb) + model_lab.predict(lab) + model_luv.predict(luv) + model_xyz.predict(xyz)) / 5
    label_pred = int(label_pred > 0.5)
    y_pred.append(label_pred)

!wget -nc https://raw.githubusercontent.com/brpy/colab-pdf/master/colab_pdf.py
from colab_pdf import colab_pdf
colab_pdf('Robotics_miniproject.ipynb')